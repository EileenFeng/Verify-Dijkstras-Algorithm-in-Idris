\section{Discussion \& Future Work} \label{discussion}
In our verification program, to prove certain properties of a function, we usually structure the proof based on the implementation of this function. For instance, if a the definition of a function includes a \inl{case} expression that matches on the result of an intermediate computation, than a proof concerned with this function can be approached by matching on the result of the same computation using the \inl{with} rule. In other words, if a function that involves more complex data types is built on other functions that involve simpler data types, a proof on this function can generally be approached by breaking the proof into smaller ones based on how the complex data types are destruct in the implementation of the function. A detailed illustration of this technique is provided in the proof of Lemma 4.3 back in Section \ref{lemma3V}.
\\

We also recognize a parallel between the mathematical proofs of our lemmas and the corresponding Idris implementations. Most of our lemma proofs are implemented following the same structure and reasonsing as the mathematical proofs. For instance, the reasoning behind the implementation of \inl{l1_prefixSP} in Section \ref{lemma1V} is highly similar the mathematical proof of Lemma 4.1 included in Section \ref{lemma4.1}. This indicates that, with a dependent typed language that allows precise specification of data type properties and function behaviors, direct translation of mathematical proofs might be a feasible approach in implementing verification programs.   
\\

\textbf{Future Work} We originally intended to verify Dijkstra's and Bellman-Ford algorithms, as both have wide real-life applications in various fields. Due to time limit we were only able to provide a verification for Dijkstra's algorithm with a few incomplete proofs. From the theoretical perspective, verifying Dijkstra's algorithm with the Idris Programming Language is feasible. As we have implemented most lemma proofs, this indicates that the current design and structure of our verification program provides a feasible approach, and that Idris is complete capable for verifying programs. However, we do recognize certain downsides in our algorithm implementation (in Section \ref{implementation}) as well as potential errors in Idris. One of the major issues concerns with a \inl{inNodeset} function defined to check whether one node is in the \inl{nodeset} of another. As an unclear type error occurs whenever we attempt to match on the value of calling \inl{inNodeset} on any two input nodes, this restricts us from obtaining enough information for completing certain lemma proofs, such as the \inl{l2_existPath} function. In spite of potential limitations, we are confident to complete the verification of Dijkstra's if granted more time. 

%The inductive step for all lemma proofs are fully implemented, and the incomplete lemmas are mainly missing base cases. Completing some of the base cases require extra information to be provided, for instance the distance value for the source node is initialized as 0, which are given by the construction of the first \inl{Column} calculated by the \inl{dijkstras} function. However as the current definitions of \inl{mkdists} and \inl{mkNodes} are 