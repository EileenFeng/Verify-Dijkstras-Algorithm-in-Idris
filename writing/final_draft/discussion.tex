\section{Discussion \& Future Work}
In our verification program, we generally structure a proof based on the implementation of functions involved in this proof. For instance, if a the definition of a function includes a \inl{case} expression that matches on the result of an intermediate computation, than a proof concerned with this function can be approached by matching on the result of the same computation using the \inl{with} rule. A similar technique in our verification process is to break a function with more complex types into smaller ones that involve simpler types, and a detailed illustration of this technique is provided in the proof of Lemma 4.3 back in Section \ref{lemma3V}.
\\

We recognize a parallel between the mathematical proofs of our lemmas and the corresponding Idris implementations. For instance, the reasoning behind the implementation of \inl{l1_prefixSP} in Section \ref{lemma1V} is highly similar the mathematical proof of Lemma 4.1 included in Section \ref{lemma4.1}. This indicates that, with a dependent typed language that allows precise specification of data type properties and function behaviors, direct translation of mathematical proofs might be a feasible approach in implementing verification programs. 
\\

\textbf{Future Work} We originally intended to verify both Dijkstra's and Bellman-Ford algorithms, as both have wide real-life applications in various fields. Due to time limit we were only able to provide a verification for Dijkstra's algorithm with a few incomplete proofs. From the theoretical perspective, verifying Dijkstra's algorithm with the Idris Programming Language is feasible. As we have implemented most lemma proofs, this indicates that the current design and structure of our verification program provides a feasible approach, and that Idris is complete capable for verifying programs. However, we do recognize certain downsides in our algorithm implementation (in Section \ref{implementation}) as well as potential errors in Idris. One of the major issues concerns with a \inl{inNodeset} function defined to check whether one node is in the \inl{nodeset} of another. As an unclear type error occurs whenever we attempt to match on the value of calling \inl{inNodeset} on any two input nodes, this restricts us from obtaining enough information for completing certain lemma proofs, such as the \inl{l2_existPath} function. In spite of potential limitations, we are confident to complete the verification of Dijkstra's if granted more time. 

%The inductive step for all lemma proofs are fully implemented, and the incomplete lemmas are mainly missing base cases. Completing some of the base cases require extra information to be provided, for instance the distance value for the source node is initialized as 0, which are given by the construction of the first \inl{Column} calculated by the \inl{dijkstras} function. However as the current definitions of \inl{mkdists} and \inl{mkNodes} are 