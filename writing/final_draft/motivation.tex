%-----------------------------------------------------------------------------------------------
% Motivation
%-----------------------------------------------------------------------------------------------
Software bugs are generally undesirable, especially in safety-critical and mission-critical systems. Back in 1985, errors in programs that controlled the Therac-25 radiation therapy machine were responsible for causing patience death by giving massive overdose of raidations \footnote{\href{https://en.wikipedia.org/wiki/Therac-25}{Therac-25 Wikipedia page}}. The Northeast Blackout in 2003 due to race condition in power control systems has affected more than 50 million people in 8 states, causing an estimated loss of over 4 billion dollars \footnote{(1) \href{https://en.wikipedia.org/wiki/Northeast_blackout_of_2003}{Northeast Blackout 2003 Wikipedia Page} (2) \href{https://elcon.org/wp-content/uploads/Economic20Impacts20of20August20200320Blackout1.pdf}{The Economic Impacts of the August 2003 Blackout}}. In practice, people usually convince themselves that a program is probably correct through testing, however as Dijkstras emphasized back in 1970s, "Program testing can be used to show the presence of bugs, but never to show their absence!" \cite{DijkstrasQuote}. Concerning the serious consequences that might caused by software errors in real life applications, it is importnat to validate the actual behaviors of programs. 
\\

As computer programs can be considered as formal mathematical objects whose properties are subject to mathematical proofs, program verification aims to provide proofs of correctness for programs by using formal, mathematical techniques \cite{Moore}. Common techniques in program verification include using proof systems, for instance the Why3 Platform \cite{why3} applies the SMT solver\footnote{\href{https://en.wikipedia.org/wiki/Satisfiability_modulo_theories}{information on SMT solver}}, and automatic verification techniques. Applications of program verification include the Compcert C Compiler, which is verified using machine-assisted mathematical proofs, and is considered exempt from miscompilation issues\footnote{\href{http://compcert.inria.fr/compcert-C.html}{main page of Compcert C}}. 
\\

In this thesis we aim to present verification as a programming issue. We want to show that with certain functional programming languages, we can specify the expected bahaviors in function type signatures, and any incorrect function definitions will fail to type check. This not only indicates that program verification can be achieved at compilation level, but more importantly, presents a technique that enforces programmers to write programs that are correct by construction. We choose Dijkstra's and Bellman-Ford algorithms as our targets as both algorithms, or variants of them, are widely applied in many fields including computer networks and artificial intelligence. 
\\

Based on the above motivations, we choose the Idris programming language for implementing our verification program \cite{idris}. Compare to other proof management systems, the Idris type checker is based on a smaller code base, which reduces the chance of introducing unexpected bugs into our verification program.
Idris is a functional programming language with dependent types, which allows programmers to provide more precise description of function's expected behaviors through its type signature. As we plan to achieve verification with type checking, this feature is essential to our verification process. In addition, the compiler-supported interactive editing feature in Idris allows programmers to inspect functions based on their type and thus to use type as guidance for writing programs, which offers considerable assistance during our implementation. Section 3 covers more backgrounds on the Idris programming language. 


%Dijkstra's and Bellman-Ford algorithms are two of the most renowned and widely-applied shortest path algorithms, however existing resource on verifying both algorithms are relatively limited. In this thesis, we offer verifications for both algorithms. In additional, we aim to present verification as a programming issue. We want to show that with certain programming languages, verifying the correctness of programs can be achieved with type checking, that if the program's correctness is not guaranteed, then our verification program will fail to be type checked.

%Verifying the correctness of programs is important, however in most real-life applications, the correctness of software is never verified directly, rather, it relies on the correctness of the algorithms it implements. This raises an issue concerning the gap between the expected and actual behavior of programs, that theoretical proof of algorithms can never validate the actual behavior of programs. The significance and value of verification, therefore, lies on the fact that it allows us to verify programs themselves rather than the algorithms behind them. 